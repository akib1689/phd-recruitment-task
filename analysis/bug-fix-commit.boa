# 1. Define input/output and keywords
p: Project = input; # Project is the top-level input type [4, 5]

# Output aggregator must use 'collection' since every generated CFG is a separate record [6].
# The output format is: project_url, commit_url, commit_message, serialized_cfg_string
fix_cfgs: output collection of string; 

# Keywords indicating bug/vulnerability fixes
keywords: array of string = {
  "fix", "bug", "error", "issue", "fault", "defect", "patch", 
  "vulnerability", "vulnerabilities", "CVE", "buffer", 
  "injection", "overflow", "npe", "security", "crash", 
  "resolve", "correct", "repair", "lint"
};

# 2. Iterate over code repositories in the project
foreach (i: int; p.code_repositories[i]) {
  project_url: string = p.project_url; # Project metadata [5]
  repo: CodeRepository = p.code_repositories[i];
  
  # 3. Iterate over commits (revisions) in the repository
  foreach (j: int; repo.revisions[j]) {
    commit: Revision = repo.revisions[j];
    
    # Pre-calculate metadata
    commit_url: string = project_url + "/commit/" + commit.id;
    
    # Get the raw commit message and prepare a clean, lowercase version for search
    msg_raw: string = commit.log; # Log message attached to the revision [5]
    msg_lower: string = lowercase(msg_raw); # Convert to lowercase [7]
    
    # Remove new line characters and carriage returns, replacing them with a space
    msg_clean: string = strreplace(msg_lower, "\n", " ", true); # [8]
    msg_clean = strreplace(msg_clean, "\r", " ", true); # [8]
    
    # 4. Check if the commit message contains any fixing keyword
    is_fix_commit: bool = false;
    foreach (k: int; keywords[k]) {
      if (strfind(keywords[k], msg_clean) != -1) { # Search for keyword [8]
        is_fix_commit = true;
        break; 
      }
    }
    
    if (is_fix_commit) {
        # 5. If it's a fixing commit, iterate over the changed files to analyze methods
        
        # Use a visitor pattern to traverse the contents of the commit
        visit(commit, visitor {
            # Target nodes of type ChangedFile [5, 9]
            before file: ChangedFile -> {
                # Get the Abstract Syntax Tree (AST) for the file [10]
                ast: ASTRoot = getast(file);
                
                # Traverse the AST to find Method declarations
                visit(ast, visitor {
                    # Target nodes of type Method [9, 11]
                    before m: Method -> {
                        # 6. Generate the Control Flow Graph (CFG) for the method [3]
                        cfg: CFG = getcfg(m);
                        
                        # 7. Serialize the CFG into Graphviz DOT string format [2]
                        # This string represents the nodes and edges (as required for the dataset)
                        cfg_dot: string = dot(cfg);
                        
                        # 8. Output the required data, comma separated
                        output_line: string = project_url + " , " + commit_url + " , " + msg_raw + " , " + cfg_dot;
                        fix_cfgs << output_line;
                    }
                });
                
                # Stop traversing the Revision object's children once the file's contents are handled, 
                # allowing the visitor to move to the next ChangedFile in the list.
                stop; # [12]
            }
        });
    }
  }
}